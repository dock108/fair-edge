name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip test execution (security and build only)'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.11'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# Global concurrency control
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Phase 1: Fast security and setup checks
  setup-and-security:
    name: Security & Setup
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      python-cache-key: ${{ steps.cache-keys.outputs.python }}
      has-backend-changes: ${{ steps.changes.outputs.backend }}
      has-ios-changes: ${{ steps.changes.outputs.ios }}
      security-passed: ${{ steps.security-check.outputs.passed }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect file changes
      uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          backend:
            - '**/*.py'
            - 'requirements*.txt'
            - 'alembic/**'
            - '.env.example'
          ios:
            - 'ios/**/*.swift'
            - 'ios/**/*.xcodeproj'

    - name: Generate cache keys
      id: cache-keys
      run: |
        echo "python=python-${{ env.PYTHON_VERSION }}-${{ hashFiles('requirements.txt', 'requirements-dev.txt') }}" >> $GITHUB_OUTPUT

    - name: Security - Secret scanning (matches pre-commit)
      run: |
        echo "ğŸ” Scanning for secrets and sensitive data..."
        
        # Check for actual hardcoded secrets (exact pre-commit match)
        if grep -r -E "(api_key|secret_key|private_key|access_token|auth_token)\s*=\s*[\"'][^\"']{16,}[\"']" --include="*.py" --include="*.js" --include="*.ts" --exclude-dir=node_modules . | grep -v "your-secret-key-here\|test_\|example_\|placeholder"; then
          echo "âŒ Potential hardcoded secrets detected"
          exit 1
        fi
        
        # Check environment files are not committed (exact pre-commit match)
        if [ -f .env ] && ! grep -q "^\.env$" .gitignore; then
          echo "âŒ .env file exists but not in .gitignore"
          exit 1
        fi
        
        echo "âœ… Secret scanning passed"

    - name: Security - Dependency audit
      id: security-check
      run: |
        echo "ğŸ”’ Auditing dependencies for vulnerabilities..."
        
        # Python dependencies
        pip install safety
        if ! safety check --json > safety_report.json; then
          echo "âŒ Python dependency vulnerabilities found"
          cat safety_report.json
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "âœ… Dependency audit passed"
        echo "passed=true" >> $GITHUB_OUTPUT

    - name: Upload security artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          safety_report.json
        retention-days: 30

  # Phase 2: Backend code quality (matches pre-commit exactly)
  code-quality-backend:
    name: Backend Code Quality
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: setup-and-security
    if: needs.setup-and-security.outputs.has-backend-changes == 'true' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ needs.setup-and-security.outputs.python-cache-key }}
        restore-keys: |
          python-${{ env.PYTHON_VERSION }}-

    - name: Install Python dependencies (exact pre-commit match)
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install black flake8 isort vulture bandit mypy pytest pytest-cov radon interrogate

    - name: Code formatting (Black) - exact pre-commit match
      run: |
        echo "ğŸ¨ Checking code formatting..."
        black --check --line-length=100 --diff .

    - name: Import sorting (isort) - exact pre-commit match
      run: |
        echo "ğŸ“¦ Checking import organization..."
        isort --check-only --profile=black --line-length=100 .

    - name: Linting (Flake8) - exact pre-commit match
      run: |
        echo "ğŸ” Running linting checks..."
        flake8 --max-line-length=100 --ignore=E203,W503 --statistics

    - name: Security linting (Bandit) - exact pre-commit match
      run: |
        echo "ğŸ”’ Running security linting..."
        bandit -r . -f json -o bandit_report.json || true
        bandit -r . -ll --skip=B101

    - name: Type checking (MyPy) - exact pre-commit match
      run: |
        echo "ğŸ”§ Running type checks..."
        mypy --ignore-missing-imports --no-strict-optional .

    - name: Code complexity (Radon) - exact pre-commit match
      run: |
        echo "ğŸ“Š Checking code complexity..."
        radon cc . --min=B --show-complexity

    - name: Documentation coverage (Interrogate) - exact pre-commit match
      run: |
        echo "ğŸ“ Checking docstring coverage..."
        interrogate --fail-under=60 .

    - name: Dead code detection (Vulture) - exact pre-commit match
      run: |
        echo "ğŸ§¹ Scanning for dead code..."
        vulture . --min-confidence=80

    - name: Project-specific checks - exact pre-commit match
      run: |
        echo "ğŸ—ï¸ Running project-specific validations..."
        
        # Check app.py size (exact pre-commit match)
        lines=$(wc -l < app.py)
        if [ $lines -gt 800 ]; then
          echo "âŒ app.py has $lines lines (limit: 800) - consider refactoring"
          exit 1
        fi
        
        # Check for boundary violations (exact pre-commit match)
        if grep -r "from app import\|import app" routes/ --include="*.py" 2>/dev/null; then
          echo "âŒ Direct app imports in routes detected - use dependency injection"
          exit 1
        fi
        
        # Check pandas/numpy imports (exact pre-commit match)
        if grep -r "import pandas\|import numpy\|from pandas\|from numpy" --include="*.py" .; then
          echo "âŒ pandas/numpy imports detected - these dependencies were removed"
          exit 1
        fi
        
        echo "âœ… Project-specific checks passed"

    - name: Upload backend quality reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: backend-quality-reports
        path: |
          bandit_report.json
        retention-days: 30

  # Phase 3: iOS code quality (matches pre-commit)
  code-quality-ios:
    name: iOS Code Quality
    runs-on: macos-latest
    timeout-minutes: 15
    needs: setup-and-security
    if: needs.setup-and-security.outputs.has-ios-changes == 'true' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '15.0'

    - name: Install SwiftLint
      run: brew install swiftlint

    - name: Install swift-format
      run: |
        git clone https://github.com/apple/swift-format.git
        cd swift-format
        swift build -c release
        sudo cp .build/release/swift-format /usr/local/bin/

    - name: SwiftLint (exact pre-commit match)
      run: |
        echo "ğŸ¨ Running SwiftLint..."
        swiftlint lint --strict ios/FairEdge/FairEdge/

    - name: Swift Format Check (exact pre-commit match)
      run: |
        echo "ğŸ“ Checking Swift formatting..."
        swift-format lint --recursive ios/FairEdge/FairEdge/

  # Phase 4: Backend testing with 80% coverage (matches pre-commit)
  test-backend:
    name: Backend Tests (80% Coverage)
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [setup-and-security, code-quality-backend]
    if: |
      always() && 
      (needs.setup-and-security.outputs.has-backend-changes == 'true' || github.event_name == 'workflow_dispatch') &&
      !inputs.skip_tests &&
      needs.setup-and-security.outputs.security-passed == 'true'

    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_USER: test_user
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache Python dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ needs.setup-and-security.outputs.python-cache-key }}
        restore-keys: |
          python-${{ env.PYTHON_VERSION }}-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-xdist pytest-html pytest-asyncio pytest-mock factory-boy responses

    - name: Create test environment
      run: |
        cat > .env.test << EOF
        DEBUG_MODE=true
        APP_ENV=test
        REDIS_URL=redis://localhost:6379/0
        SUPABASE_URL=https://test.supabase.co
        SUPABASE_ANON_KEY=test_key
        SUPABASE_JWT_SECRET=test_secret_that_is_long_enough_for_jwt_validation
        SUPABASE_SERVICE_ROLE_KEY=test_service_key
        THE_ODDS_API_KEY=test_api_key
        DB_CONNECTION_STRING=postgresql+asyncpg://test_user:test_password@localhost:5432/test_db
        DATABASE_URL=postgresql://test_user:test_password@localhost:5432/test_db
        ODDS_API_KEY=test_api_key
        EOF

    - name: Set up test database
      run: |
        export $(cat .env.test | xargs)
        python -c "
        import asyncio
        import asyncpg
        async def setup():
          conn = await asyncpg.connect('postgresql://test_user:test_password@localhost:5432/test_db')
          await conn.execute('CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"')
          await conn.close()
        asyncio.run(setup())
        "

    - name: Run tests with 80% coverage requirement (exact pre-commit match)
      run: |
        export $(cat .env.test | xargs)
        echo "ğŸ§ª Running tests with 80% coverage requirement..."
        pytest --cov=. --cov-fail-under=80 --cov-report=term-missing --cov-report=xml --cov-report=html --html=test_report.html --self-contained-html --junitxml=test_results.xml -x

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: backend-test-results
        path: |
          test_report.html
          test_results.xml
          coverage.xml
          htmlcov/
        retention-days: 30

    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: backend
        name: backend-coverage

  # Phase 5: iOS testing
  test-ios:
    name: iOS Tests
    runs-on: macos-latest
    timeout-minutes: 20
    needs: [setup-and-security, code-quality-ios]
    if: |
      always() && 
      (needs.setup-and-security.outputs.has-ios-changes == 'true' || github.event_name == 'workflow_dispatch') &&
      !inputs.skip_tests &&
      needs.setup-and-security.outputs.security-passed == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '15.0'

    - name: iOS Unit Tests (exact pre-commit match when tests exist)
      run: |
        cd ios/FairEdge
        echo "ğŸ§ª Running iOS unit tests..."
        if xcodebuild -list -project FairEdge.xcodeproj | grep -q "FairEdgeTests"; then
          xcodebuild test -scheme FairEdge -destination "platform=iOS Simulator,name=iPhone 15,OS=17.0"
        else
          echo "âš ï¸ No test scheme found, creating placeholder test results"
          echo "iOS test infrastructure ready for implementation"
        fi

    - name: iOS Build Validation
      run: |
        cd ios/FairEdge
        echo "ğŸ—ï¸ Validating iOS build..."
        xcodebuild build -scheme FairEdge -destination "platform=iOS Simulator,name=iPhone 15,OS=17.0"

  # Final summary job
  ci-summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [setup-and-security, code-quality-backend, code-quality-ios, test-backend, test-ios]
    if: always()

    steps:
    - name: Evaluate results
      run: |
        echo "ğŸ“‹ CI Pipeline Summary"
        echo "====================="
        
        echo "ğŸ”’ Security: ${{ needs.setup-and-security.result }}"
        echo "ğŸ¨ Backend Quality: ${{ needs.code-quality-backend.result }}"
        echo "ğŸ¨ iOS Quality: ${{ needs.code-quality-ios.result }}"
        echo "ğŸ§ª Backend Tests: ${{ needs.test-backend.result }}"
        echo "ğŸ§ª iOS Tests: ${{ needs.test-ios.result }}"
        
        # Determine overall status
        if [[ "${{ needs.setup-and-security.result }}" == "failure" ]]; then
          echo "âŒ Pipeline failed due to security issues"
          exit 1
        elif [[ "${{ needs.test-backend.result }}" == "failure" ]]; then
          echo "âŒ Pipeline failed due to backend test failures"
          exit 1
        elif [[ "${{ needs.code-quality-backend.result }}" == "failure" ]]; then
          echo "âŒ Pipeline failed due to backend quality issues"
          exit 1
        elif [[ "${{ needs.code-quality-ios.result }}" == "failure" ]]; then
          echo "âŒ Pipeline failed due to iOS quality issues"
          exit 1
        else
          echo "âœ… Pipeline completed successfully"
        fi